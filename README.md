# Жадібні алгоритми та динамічне програмування

## Опис домашнього завдання

Маємо набір монет [50, 25, 10, 5, 2, 1]. Уявіть, що ви розробляєте систему для касового апарату, яка повинна визначити оптимальний
спосіб видачі решти покупцеві.

Вам необхідно написати дві функції для касової системи, яка видає решту покупцеві:

Функція жадібного алгоритму find_coins_greedy. Ця функція повинна приймати суму, яку потрібно видати покупцеві, і повертати словник із
кількістю монет кожного номіналу, що використовуються для формування цієї суми. Наприклад, для суми 113 це буде словник {50: 2, 10: 1,
2: 1, 1: 1}. Алгоритм повинен бути жадібним, тобто спочатку вибирати найбільш доступні номінали монет.
Функція динамічного програмування find_min_coins. Ця функція також повинна приймати суму для видачі решти, але використовувати метод
динамічного програмування, щоб знайти мінімальну кількість монет, необхідних для формування цієї суми. Функція повинна повертати
словник із номіналами монет та їх кількістю для досягнення заданої суми найефективнішим способом. Наприклад, для суми 113 це буде
словник {1: 1, 2: 1, 10: 1, 50: 2}
Порівняйте ефективність жадібного алгоритму та алгоритму динамічного програмування, базуючись на часі їх виконання або О великому та
звертаючи увагу на їхню продуктивність при великих сумах. Висвітліть, як вони справляються з великими сумами та чому один алгоритм може
бути більш ефективним за інший у певних ситуаціях.

## Висновки

### Жадібний алгоритм (find_coins_greedy)

Суть: вибирає найбільші доступні монети на кожному кроці, доки не набере потрібну суму.

Складність: O(n) — де n — кількість типів монет.

Переваги:

    Дуже швидкий (майже миттєвий).
    Простий у реалізації.

Недоліки:

Не гарантує мінімальної кількості монет, якщо номінали не дозволяють таке покриття.

Працює правильно лише з "жадібною" системою монет, як в нашому прикладі(1). У прикладі(2) вже не набирає потрібну суму через зміну
набору монет з coins = [50, 25, 10, 5, 2, 1] на coins = [50, 25, 10, 5, 2]

### Алгоритм динамічного програмування (find_min_coins)

Суть: Будує оптимальне рішення для кожної суми від 1 до amount, зберігаючи мінімальну кількість монет.

Складність: O(amount \* n) — де n — кількість типів монет.

Переваги:

Завжди знаходить найменшу кількість монет.

Працює навіть з нежадібними системами монет (напр., [50, 25, 10, 5, 2]).

Недоліки:

Повільніше за жадібний при дуже великих сумах (але незначно, як видно з замірів).

Приклад 1 (coins = [50, 25, 10, 5, 2, 1])
|---------------------|----------------------------|-------------------|
| Алгоритм | Результат | Час виконання (с) |
|---------------------|----------------------------|-------------------|
| Жадібний (Greedy) | {50: 2, 10: 1, 2: 1, 1: 1} | 0.000007600000 |
|---------------------|----------------------------|-------------------|
| Динамічний (DP) | {50: 2, 10: 1, 2: 1, 1: 1} | 0.000116099996 |
|---------------------|----------------------------|-------------------|

Приклад 2 (coins = [50, 25, 10, 5, 2])
|---------------------|----------------------------|-------------------|
| Алгоритм | Результат | Час виконання (с) |
|---------------------|----------------------------|-------------------|
| Жадібний (Greedy) | {50: 2, 10: 1, 2: 1} | 0.000008899995 |
|---------------------|----------------------------|-------------------|
| Динамічний (DP) | {50: 2, 5: 1, 2: 4} | 0.000137199997 |
|---------------------|----------------------------|-------------------|
